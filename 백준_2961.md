# 백준 2961번 도영이가 만든 맛있는 음식

### 문제 설명

- 문제
  - 재료의 신맛과 쓴맛이 주어졌을 때, 신맛과 쓴맛의 차이가 가장 작은 요리를 만드는 프로그램을 작성하시오.
- 입력
  - 첫째 줄에 재료의 개수 N(1 ≤ N ≤ 10)이 주어진다. 다음 N개 줄에는 그 재료의 신맛과 쓴맛이 공백으로 구분되어 주어진다. 
  - 모든 재료를 사용해서 요리를 만들었을 때, 그 요리의 신맛과 쓴맛은 모두 1,000,000,000보다 작은 양의 정수이다.
- 출력
  - 첫째 줄에 신맛과 쓴맛의 차이가 가장 작은 요리의 차이를 출력한다. 



### :full_moon_with_face: 내가 푼 답

```java
import java.util.Scanner;

public class 백준_2961 {
	
	// 재료들의 맛 차이가 제일 작은거 저장
	static int max_small;
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		// 재료수
		int N = sc.nextInt();
		// 재료의 맛
		int flavor[][] = new int[N][2];
		// 재료를 사용했는지 안했는지
		boolean visited[] = new boolean[N];
		
		// 입력
		for(int i=0;i<N;i++) {
			flavor[i][0] = sc.nextInt();
			flavor[i][1] = sc.nextInt();
		}
		
		// 제일 작은 값을 찾는거라서 큰값을 넣어놈
		max_small = 1000000000;
		find_small(flavor, visited, N, 0);
		System.out.println(max_small);
	}
	
	static void find_small(int flavor[][], boolean visited[], int N, int idx) {
		// 재료를 다 뽑았다면
		if(idx == N) {
			// 재료들의 신맛, 쓴맛 저장 변수
			long sour = 1, bitter = 0;
			// 재료가 1개 이상 쓰여야되므로 체크하는 변수 만듦
			boolean check = false;
			
			for(int i=0;i<N;i++)
				// 만약 그 재료가 사용됐다면
				if(visited[i]) {
					// 재료들의 맛 점수 저장
					sour *= flavor[i][0];
					bitter += flavor[i][1];
					// 재료 1개이상쓰인걸 체크
					check = true;
				}
			
			// 재료가 1개이상 쓰였고 맛의 차이가 현재 제일 작은 차이보다 작다면 max_small값 갱신
			if(check && (Math.abs(sour - bitter) < max_small))
				max_small = Math.abs((int) (sour - bitter));
		
			return;
		}
		
		// 재료 안 쓴 경우
		visited[idx] = false;
		find_small(flavor, visited, N, idx+1);
		// 재료를 쓴 경우
		visited[idx] = true;
		find_small(flavor, visited, N, idx+1);
	}

}
```



#### :cake: 문제를 풀면서

- 이렇게도 처음 계획과 많이 다를 수가 있구나... 지금까지는 대충 이러면 되겠지...라는 마음으로 손코딩한걸 옮기고 오류가 나면 계속 수정해서 한번에 코드를 짜는게 없었는데 그러면 안될꺼같다.. 앞으로 많이 연습해야지..



###  문제 풀이 과정

- 처음에 생각한대로 짜본 순서도

  - 문제점: 처음부터 끝까지 다 문제다... 부분집합과 순열을 동시에 사용한것같다. 그리고 너무 복잡하게 생각했다. 신맛과 쓴맛의 차이는 맛 배열만 있다면 구할 수 있기때문에 굳이 인자로 넘길 필요가 없었다.

  ```java
  static int 재료수
  static int[][] 맛
  static boolean 방문
  
  int find(신맛, 쓴맛, 제일작은요리차이, 인덱스)
      if(인덱스가 넘어가면)
          return 제일작은요리차이
          
      for(i=인덱스+1;i<N;i++)
          if(그 재료를 선택했다면)
              continue;
  
  		방문[i] = true
              
          int 재료안더한거 = find(신맛, 쓴맛, 제일작은요리차이, i)
              
  		int 신맛곱한거 = 신맛x맛[i][0]
          int 쓴맛더하기 = 쓴맛+맛[i][0]
              
          int 새로운작은차이;
          if(신맛곱하거-쓴맛더한거 < 제일작은요리차이)
              새로운작은차이 = 신맛-쓴맛
              
          int 재료더한거 = find(신맛곱한거, 쓴맛더한거, 새로운작은차이, i)
       
      return 재료안더한거 > 재료더한거 ? 재료더한거 : 재료안더한거   
  
  main문
      재료수 = sc.next
      맛 = new int[재료수][2]
      
      for(i=0;i<N;i++)
          맛[i][0] = sc.nextInt();
  		맛[i][1] = sc.nextInt();
  
      print(fid(맛[0][0], 맛[0][1], 1000000000, 0))
  ```

  

- 생각 못한것

  - 최소한 재료한개는 들어가야된ㄴ다.
  - 신맛이랑 쓴맛 빼고 값을 절댓값으로 비교해야한다.
  - 조합이나 부분집합은 for문안에서 재귀호출하지말아라(중복이 많이 된다.)

  

  

  #### :globe_with_meridians: 출처

  - https://www.acmicpc.net/problem/2961

  

  