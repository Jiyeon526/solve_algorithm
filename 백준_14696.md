# 백준 14696번 딱지놀이

### 문제설명

- 문제
  - 만약 두 딱지의 별의 개수가 다르다면, 별이 많은 쪽의 딱지가 이긴다.
  - 별의 개수가 같고 동그라미의 개수가 다르다면, 동그라미가 많은 쪽의 딱지가 이긴다.
  - 별, 동그라미의 개수가 각각 같고 네모의 개수가 다르다면, 네모가 많은 쪽의 딱지가 이긴다.
  - 별, 동그라미, 네모의 개수가 각각 같고 세모의 개수가 다르다면, 세모가 많은 쪽의 딱지가 이긴다.
  - 별, 동그라미, 네모, 세모의 개수가 각각 모두 같다면 무승부이다.
  - 별, 동그라미, 네모, 세모를 각각 숫자 4, 3, 2, 1로 표현한다. 
- 입력
  - N 라운드 수 입력한 뒤, 다음줄에는 A의 카드 수와 카드들, B의 카드수와 카드들이 들어온다.
- 출력
  - 각 라운드의 결과는 A가 승자라면 A, B가 승자라면 B, 무승부라면 D이다.



### :full_moon_with_face: 내가 푼 답

```java
import java.util.Arrays;
import java.util.Scanner;

public class 백준_14696 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		//총 라운드수
		int N = sc.nextInt();
		
		for(int i=0;i<N;i++) {
			// A의 카드입력
			int A_num = sc.nextInt();
			int[] A = new int[4];
			for(int j=0;j<A_num;j++) {
				int num = sc.nextInt();
				A[num-1]++;
			}
			
			// B의 카드입력
			int B_num = sc.nextInt();
			int[] B = new int[4];
			for(int j=0;j<B_num;j++) {
				int num = sc.nextInt();
				B[num-1]++;
			}

			String win = "";
			for(int j=3;j>=0;j--)
				if(A[j] != B[j]) {
					win = A[j]>B[j]?"A":"B";
					break;
				}
			if(win == "")
				win = "D";
			
			System.out.println(win);
		}

	}

}
```

- 접근: 처음에는 A, B배열에 들어오는 수를 다 저장하고 정렬해서 비교를 하려고했다. 비교를 해서 다른 수이면 숫자가 큰 쪽이 이기는 형식을 while문을 돌릴려했는데 생각해보니 1, 2, 3, 4 카드들을 인덱스로 쓰고 갯수를 미리 세는 형식이 나름 메모리를 덜 쓸거같아서 위에 같이 풀었다.





#### :globe_with_meridians: 출처

- https://www.acmicpc.net/problem/14696