# 백준 1992번 쿼드트리

### 문제설명

- 문제
  - 주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고, 모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다
- 입력
  - 첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.
- 출력
  - 영상을 압축한 결과를 출력한다.



### :fearful: 내가 푼 답

```java
//주어진 nxn 크기의 1, 0의 합
//1인거의 합이 n제곱이면  전체가 1로 이뤄짐
//0인거의 합이 0이면 0으로 이뤄짐
//==>분할안함, 기저조건
//그외=>섞여있는 경우, 유도파트
//4개의 사각형을 다시 재귀로


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 백준_1992 {

	static int quad[][];
	
	public static void main(String[] args) throws IOException {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(bf.readLine());
		quad = new int[N][N];
		
		// 영상 압축 결과 입력
		for(int i=0;i<N;i++) {
			String[] str = bf.readLine().split("");
			for(int j=0;j<N;j++) {
				int num = Integer.parseInt(str[j]);
				quad[i][j] = num;
			}
		}
		
		System.out.println(Quad_Tree(0,0,N-1,N-1,0));
	}
	
	static String Quad_Tree(int si, int sj, int ei, int ej, int cnt) {
		// 4분면으로 나눠주는 기준
		int len = (ei-si+1)/2;
		// 답 저장
		String zip = "(";
		// 만약 0이나 1로 이뤄지지 않았을때 체크
		boolean check = true;
		
		// 숫자가 1개라면 그 숫자 출력하고 끝
		if(len == 0)
			return Integer.toString(quad[si][sj]);
		
		// 1사분면
		for(int i=si;i<si+len;i++) {
			for(int j=sj;j<sj+len;j++)
				// 같지 않다는건 다른 숫자가 섞여있는거니깐 재귀를 통해 해결
				if(quad[i][j] != quad[si][sj]) {
					check = false;
					zip += Quad_Tree(si, sj, si+len-1, sj+len-1, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		// 만약 다 똑같은 숫자로 이뤄져있으면 배열의 첫번째 숫자 저장
		if(check)
			zip += quad[si][sj];
		check = true;
		
		// 2사분면
		for(int i=si;i<si+len;i++) {
			for(int j=sj+len;j<ej+1;j++)
				if(quad[i][j] != quad[si][sj+len]) {
					check = false;
					zip += Quad_Tree(si, sj+len, si+len-1, ej, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si][sj+len];
		check = true;
		
		// 3사분면
		for(int i=si+len;i<ei+1;i++) {
			for(int j=sj;j<sj+len;j++)
				if(quad[i][j] != quad[si+len][sj]) {
					check = false;
					zip += Quad_Tree(si+len, sj, ei, sj+len-1, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si+len][sj];
		check = true;
		
		// 4사분면
		for(int i=si+len;i<ei+1;i++) {
			for(int j=sj+len;j<ej+1;j++)
				if(quad[i][j] != quad[si+len][sj+len]) {
					check = false;
					zip += Quad_Tree(si+len, sj+len, ei, ej, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si+len][sj+len];
		check = true;
		
		// 마지막에 괄호 닫아줌
		zip += ")";

		// 재귀를 안돌았을때 모두 같은 수로 이뤄져있는지 아닌지 확인
		boolean c = true;
		// 6인 이유는 함수를 한번만 수행하면 (1101)이런 식으로 나와서 cnt는 재귀의 깊이
		if(zip.length() == 6 && cnt == 0) {
			// 모든 사분면이 같은 숫자인지 확인
			for(int i=1;i<4;i++)
				// 만약 하나라도 다르면 그냥 괄호 제거하고 출력
				if(zip.charAt(i) != zip.charAt(i+1)) {		
//					zip = zip.substring(1, 5);
					c = false;
					break;
				}
			// 모두 같은 숫자라면 1개만 출력
			if(c)
				zip = zip.substring(1, 2);
		}
			
		return zip;
	}

}

```



### 풀이 과정

- 접근: 입력받은 배열을 4분면으로 나눠서(중간을 기준으로) 4개의 사분면을 다 검사한뒤 다른 숫자로 이뤄져있다면 재귀를 통해 해결하고 아니라면 그 숫자 출력하게 만들었다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 백준_1992 {

	static int quad[][];
	
	public static void main(String[] args) throws IOException {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(bf.readLine());
		quad = new int[N][N];
		
		// 영상 압축 결과 입력
		for(int i=0;i<N;i++) {
			String[] str = bf.readLine().split("");
			for(int j=0;j<N;j++) {
				int num = Integer.parseInt(str[j]);
				quad[i][j] = num;
			}
		}
		
		System.out.println(Quad_Tree(0,0,N-1,N-1,0));
	}
	
	static String Quad_Tree(int si, int sj, int ei, int ej, int cnt) {
		// 4분면으로 나눠주는 기준
		int len = (ei-si+1)/2;
		// 답 저장
		String zip = "(";
		// 만약 0이나 1로 이뤄지지 않았을때 체크
		boolean check = true;
		
		// 숫자가 1개라면 그 숫자 출력하고 끝
		if(len == 0)
			return Integer.toString(quad[si][sj]);
		
		// 1사분면
		for(int i=si;i<si+len;i++) {
			for(int j=sj;j<sj+len;j++)
				// 같지 않다는건 다른 숫자가 섞여있는거니깐 재귀를 통해 해결
				if(quad[i][j] != quad[si][sj]) {
					check = false;
					zip += Quad_Tree(si, sj, si+len-1, sj+len-1, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		// 만약 다 똑같은 숫자로 이뤄져있으면 배열의 첫번째 숫자 저장
		if(check)
			zip += quad[si][sj];
		check = true;
		
		// 2사분면
		for(int i=si;i<si+len;i++) {
			for(int j=sj+len;j<ej+1;j++)
				if(quad[i][j] != quad[si][sj+len]) {
					check = false;
					zip += Quad_Tree(si, sj+len, si+len-1, ej, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si][sj+len];
		check = true;
		
		// 3사분면
		for(int i=si+len;i<ei+1;i++) {
			for(int j=sj;j<sj+len;j++)
				if(quad[i][j] != quad[si+len][sj]) {
					check = false;
					zip += Quad_Tree(si+len, sj, ei, sj+len-1, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si+len][sj];
		check = true;
		
		// 4사분면
		for(int i=si+len;i<ei+1;i++) {
			for(int j=sj+len;j<ej+1;j++)
				if(quad[i][j] != quad[si+len][sj+len]) {
					check = false;
					zip += Quad_Tree(si+len, sj+len, ei, ej, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si+len][sj+len];
		check = true;
		
		// 마지막에 괄호 닫아줌
		zip += ")";

		// 재귀를 안돌았을때 모두 같은 수로 이뤄져있는지 아닌지 확인
		boolean c = true;
		// 6인 이유는 함수를 한번만 수행하면 (1101)이런 식으로 나와서 cnt는 재귀의 깊이
		if(zip.length() == 6 && cnt == 0) {
			// 모든 사분면이 같은 숫자인지 확인
			for(int i=1;i<4;i++)
				// 만약 하나라도 다르면 그냥 괄호 제거하고 출력
				if(zip.charAt(i) != zip.charAt(i+1)) {		
					zip = zip.substring(1, 5);
					c = false;
					break;
				}
			// 모두 같은 숫자라면 1개만 출력
			if(c)
				zip = zip.substring(1, 2);
		}
		return zip;
	}
}
```

- 왜 도대체 왜!!! 틀린지 모르겠다...
  - 후.... if문에서 zip = zip.substring(1, 5);이거 지웠어야됐다..... 문제를 제대로 분석한다는게 이렇게힘들줄이야... 시간이 너무 없다. 

