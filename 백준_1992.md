# 백준 1992번 쿼드트리

### 문제설명

- 문제
- 입력
- 출력



### :fearful: 내가 푼 답

```java

```



### 풀이 과정

- 접근: 입력받은 배열을 4분면으로 나눠서(중간을 기준으로) 4개의 사분면을 다 검사한뒤 다른 숫자로 이뤄져있다면 재귀를 통해 해결하고 아니라면 그 숫자 출력하게 만들었다.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 백준_1992 {

	static int quad[][];
	
	public static void main(String[] args) throws IOException {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(bf.readLine());
		quad = new int[N][N];
		
		// 영상 압축 결과 입력
		for(int i=0;i<N;i++) {
			String[] str = bf.readLine().split("");
			for(int j=0;j<N;j++) {
				int num = Integer.parseInt(str[j]);
				quad[i][j] = num;
			}
		}
		
		System.out.println(Quad_Tree(0,0,N-1,N-1,0));
	}
	
	static String Quad_Tree(int si, int sj, int ei, int ej, int cnt) {
		// 4분면으로 나눠주는 기준
		int len = (ei-si+1)/2;
		// 답 저장
		String zip = "(";
		// 만약 0이나 1로 이뤄지지 않았을때 체크
		boolean check = true;
		
		// 숫자가 1개라면 그 숫자 출력하고 끝
		if(len == 0)
			return Integer.toString(quad[si][sj]);
		
		// 1사분면
		for(int i=si;i<si+len;i++) {
			for(int j=sj;j<sj+len;j++)
				// 같지 않다는건 다른 숫자가 섞여있는거니깐 재귀를 통해 해결
				if(quad[i][j] != quad[si][sj]) {
					check = false;
					zip += Quad_Tree(si, sj, si+len-1, sj+len-1, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		// 만약 다 똑같은 숫자로 이뤄져있으면 배열의 첫번째 숫자 저장
		if(check)
			zip += quad[si][sj];
		check = true;
		
		// 2사분면
		for(int i=si;i<si+len;i++) {
			for(int j=sj+len;j<ej+1;j++)
				if(quad[i][j] != quad[si][sj+len]) {
					check = false;
					zip += Quad_Tree(si, sj+len, si+len-1, ej, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si][sj+len];
		check = true;
		
		// 3사분면
		for(int i=si+len;i<ei+1;i++) {
			for(int j=sj;j<sj+len;j++)
				if(quad[i][j] != quad[si+len][sj]) {
					check = false;
					zip += Quad_Tree(si+len, sj, ei, sj+len-1, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si+len][sj];
		check = true;
		
		// 4사분면
		for(int i=si+len;i<ei+1;i++) {
			for(int j=sj+len;j<ej+1;j++)
				if(quad[i][j] != quad[si+len][sj+len]) {
					check = false;
					zip += Quad_Tree(si+len, sj+len, ei, ej, cnt+1);
					break;
				}
			if(!check)
				break;		
		}
		if(check)
			zip += quad[si+len][sj+len];
		check = true;
		
		// 마지막에 괄호 닫아줌
		zip += ")";

		// 재귀를 안돌았을때 모두 같은 수로 이뤄져있는지 아닌지 확인
		boolean c = true;
		// 6인 이유는 함수를 한번만 수행하면 (1101)이런 식으로 나와서 cnt는 재귀의 깊이
		if(zip.length() == 6 && cnt == 0) {
			// 모든 사분면이 같은 숫자인지 확인
			for(int i=1;i<4;i++)
				// 만약 하나라도 다르면 그냥 괄호 제거하고 출력
				if(zip.charAt(i) != zip.charAt(i+1)) {		
					zip = zip.substring(1, 5);
					c = false;
					break;
				}
			// 모두 같은 숫자라면 1개만 출력
			if(c)
				zip = zip.substring(1, 2);
		}
		return zip;
	}
}
```

- 왜 도대체 왜!!! 틀린지 모르겠다...

