# 치킨 배달

### 문제 설명

- 문제
  - 이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 "**치킨 거리**"라는 말을 주로 사용한다. **치킨 거리**는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 **치킨 거리**를 가지고 있다. **도시의 치킨 거리**는 모든 집의 **치킨 거리**의 합이다.
  - 도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, **도시의 치킨 거리**가 가장 작게 될지 구하는 프로그램을 작성하시오.
- 입력
  - 첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.
  - 둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.
  - 도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.
- 출력
  - 첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.



### :full_moon_with_face: 내가 푼 답

```java
import java.util.Scanner;

public class 백준_15686 {

	static boolean check[];
	static int ans_small;
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int M = sc.nextInt();
		// 치킨집의 최대값은 13, x, y좌표를 받음
		int[][] chicken = new int[13][2];
		// 집의 최대값은 2*N, x,y좌표를 받음
		int[][] home = new int[2*N+1][2];
		
		// 치킨집 갯수, 집의 갯수
		int chicken_len = 0, home_len = 0;
		for(int i=0;i<N;i++)
			for(int j=0;j<N;j++) {
				// 배열을 받음
				int num = sc.nextInt();
				// 치킨집이면
				if(num == 2) {
					// 순서대로 치킨 배열에 치킨집 좌표를 넣음
					chicken[chicken_len][0] = i+1;
					// 치킨집 좌표를 넣고나면 인덱스를 하나씩 늘려준다.
					chicken[chicken_len++][1] = j+1;
				}
				// 집이라면
				else if(num == 1) {
					// 치킨집과 마찬가지로 집의 좌표를 넣어줌
					home[home_len][0] = i+1;
					home[home_len++][1] = j+1;
				}
			}
		
		// 치킨집과 집사이의 거리를 기록(치킨집 기준)
		int[][] location = new int[chicken_len][home_len];
		
		for(int i=0;i<chicken_len;i++)
			for(int j=0;j<home_len;j++)
				//치킨집기준으로해서 치킨집과 집 사이의 거리차를 저장
				location[i][j] = Math.abs(chicken[i][0] - home[j][0]) + Math.abs(chicken[i][1] - home[j][1]);
		
		// 대충 큰 값
		ans_small = 10000000;
		// 이 치킨집을 선택했는지 안했는지 확인용
		check = new boolean[chicken_len];
		// cnt는 몇개뽑았는지
		find(0, home_len, chicken_len, location, 0, M);
		System.out.println(ans_small);
	}
	
	static void find(int idx, int home_len, int chicken_len, int[][] location, int cnt, int M) {
		// 치킨집을 처음부터 끝까지 다 확인했거나 M개를 뽑았을 경우
		if(idx == chicken_len || cnt == M) {
			// 뽑은 차이들 중 작은 값들만 저장
			int small[] = new int[home_len];
			
			// 초기화
			for(int i=0;i<home_len;i++)
				small[i] = 101;
			
			for(int i=0;i<chicken_len;i++)
				// 치킨집을 선택했다면
				if(check[i])
					for(int j=0;j<home_len;j++)
						// 차이를 비교해서 더 작다면 small에 넣음
						if(location[i][j] < small[j])
							small[j] = location[i][j];
			
			// small 값들 의 합(도시의 치킨 거리 값들의 합)
			int sum = 0;
			for(int i=0;i<home_len;i++)
				sum += small[i];
			
			// 만약 그 합이 이전에 들어있던 작은 값보다도 더 작다면 변경
			if(sum < ans_small)
				ans_small = sum;
			
			return;
		}
		
		check[idx] = true;
		find(idx+1, home_len, chicken_len, location, cnt+1, M);
		check[idx] = false;
		find(idx+1, home_len, chicken_len, location, cnt, M);
	}

}
```



### 풀이 과정

- 처음 생각: 치킨집 중 M개를 뽑아(check를 ture로 기록) 얘네들을 가지고 location과 small중 작은 값을 기록해서 제일 작은 도시의 치키거리를 찾겠다! 라고 생각해서 아래와 같이 find함수를 만들었다.
- 문제점: M개를 뽑아야지 하고 정작 M개를 뽑아내는 조건이나 변수를 만들지 않아서 모든 경우의 수가 다 나왔다.
- 해결: 답 코드에 보면 find함수에 cnt(몇 개 뽑았는지 기록), M을 인자로 줘서 true일때만 cnt가 1씩 늘어나도록 해줬다.

```java
static void find(int idx, int home_len, int chicken_len, int[][] location) {
    if(idx == chicken_len) {
        int small[] = new int[home_len];

        for(int i=0;i<home_len;i++)
            small[i] = 101;

        for(int i=0;i<idx;i++) {
            if(check[i]) {
                for(int j=0;j<home_len;j++)
                    if(location[i][j] < small[i])
                        small[i] = location[i][j];
            }
        }
        int sum = 0;
        for(int i=0;i<home_len;i++)
            sum += small[i];

        if(sum < ans_small)
            ans_small = sum;

        return;
    }

    check[idx] = true;
    find(idx+1, home_len, chicken_len, location);
    check[idx] = false;
    find(idx+1, home_len, chicken_len, location);
}
```





#### :cake: 문제 풀면서

- 처음 계획서를 만들고 그대로 코드로 옮기면서 중간중간 빼먹은 조건들이 생각나서 그제서야 붙이기도 하고 수정한다. 처음부터 완벽한 계획을 짜야되는데 쉽지가 않다. 그래도 오늘 푼 문제는 내 수준보다 높은 문제라고 생각했는데 1시간 반이나 걸렸지만 풀어서 뿌듯!



#### :globe_with_meridians: 출처

- https://www.acmicpc.net/problem/15686