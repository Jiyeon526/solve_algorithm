# 백준 14888번 연산자 끼워넣기

### 문제설명

- 문제
- 입력
- 출력



### :full_moon_with_face: 내가 푼 답

```python

```



### 풀이 과정

- 우선 연산자를 1, 2, 3, 4로 바꿔서 계산했다. 그리고 그 숫자들을 순열로 만들어서 모든 경우의 수를 다 계산하게했지만 시간 초과가 났다.

```python
import sys

input = sys.stdin.readline
sys.setrecursionlimit(10**9)

def cal(cnt, N):
    global max_number
    global min_number

    if cnt == len(number)-1:
        # print11(cal_op)
        res = number[0]
        for i in range(cnt):
            if cal_op[i] == 1:
                res += number[i+1]
            elif cal_op[i] == 2:
                res -= number[i+1]
            elif cal_op[i] == 3:
                res *= number[i+1]
            else:
                check = 1 if res > 0 else -1
                res *= check
                res //= number[i+1]
                res *= check
                  
        if res < min_number:
            min_number = res
        if res > max_number:
            max_number = res

    for i in range(N-1):
        if not selected[i]:
            cal_op[cnt] = operator[i]
            selected[i] = True
            cal(cnt+1, N)
            selected[i] = False


N = int(input())
number = list(map(int, input().split()))
op = list(map(int, input().split())) 
operator = [0 for _ in range(N-1)]
cal_op = [0 for _ in range(len(number)-1)]
selected = [False for _ in range(N-1)]
x = 0

for i in range(4):
    for _ in range(op[i]):
        operator[x] = i+1
        x += 1

max_number, min_number = -1000000000, 1000000000
cal(0, N)
print(max_number, min_number)
```

- 다른 풀이: 입력 받은 연산자를 하나씩 줄여가면서 계산하는 방법! 참 어렵다..

```python
 if divi > 0:
        check = 1 if cal_num > 0 else -1
        cal_num *= check
        cal_num //= number[cnt]
        cal_num *= check
        print("d", cal_num, cnt)
        cal(cnt+1, cal_num, plus, minus, multi, divi-1) 
        초기화 안해줌
```

